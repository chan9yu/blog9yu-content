---
title: "React 성능 최적화 완벽 가이드"
short_description: "React 애플리케이션의 성능을 개선하는 실전 기법과 패턴을 소개합니다."
url_slug: "react-performance-optimization"
released_at: "2025-10-05T00:00:00.000Z"
updated_at: "2025-10-06T00:00:00.000Z"
is_private: false
tags: ["React", "Performance", "Frontend", "Optimization"]
---

React 애플리케이션의 성능을 개선하는 다양한 기법을 실전 예제와 함께 알아봅니다.

# 서론

React로 개발하다 보면 컴포넌트가 불필요하게 재렌더링되거나, 복잡한 계산이 반복되는 경우를 자주 마주하게 됩니다.
이러한 문제는 초기에는 눈에 띄지 않지만, 애플리케이션이 커질수록 사용자 경험에 큰 영향을 미치게 됩니다.

이 글에서는 React 성능 최적화의 핵심 개념과 실전 기법을 다룹니다.

# 1. React 렌더링 이해하기

React의 렌더링 프로세스를 이해하는 것이 최적화의 첫걸음입니다.

## 렌더링이 발생하는 경우

1. **State 변경**: `useState`, `useReducer`로 관리하는 상태가 변경될 때
2. **Props 변경**: 부모 컴포넌트가 전달하는 props가 변경될 때
3. **부모 컴포넌트 렌더링**: 부모가 렌더링되면 자식도 함께 렌더링

```jsx
function ParentComponent() {
	const [count, setCount] = useState(0);

	return (
		<div>
			<button onClick={() => setCount(count + 1)}>증가</button>
			{/* count가 변경되면 ChildComponent도 재렌더링 */}
			<ChildComponent />
		</div>
	);
}
```

# 2. 메모이제이션 기법

## React.memo

컴포넌트를 메모이제이션하여 props가 변경되지 않으면 재렌더링을 방지합니다.

```jsx
const ExpensiveComponent = React.memo(({ data }) => {
	console.log("렌더링!");
	return <div>{data}</div>;
});
```

**주의사항:**

- 객체나 함수를 props로 전달할 때는 `useMemo`, `useCallback`과 함께 사용
- 모든 컴포넌트에 적용하지 말고, 실제 성능 이슈가 있는 곳에만 적용

## useMemo

복잡한 계산 결과를 캐싱합니다.

```jsx
function DataProcessor({ data }) {
	const processedData = useMemo(() => {
		return data
			.filter((item) => item.active)
			.map((item) => ({ ...item, processed: true }))
			.sort((a, b) => b.priority - a.priority);
	}, [data]);

	return <Table data={processedData} />;
}
```

## useCallback

함수를 메모이제이션하여 참조 동일성을 유지합니다.

```jsx
function SearchComponent() {
	const [query, setQuery] = useState("");

	const handleSearch = useCallback((value) => {
		setQuery(value);
		// API 호출 등의 로직
	}, []);

	return <SearchInput onSearch={handleSearch} />;
}
```

# 3. 리스트 렌더링 최적화

## key 속성 올바르게 사용하기

```jsx
// ❌ 나쁜 예: index를 key로 사용
{
	items.map((item, index) => <ListItem key={index} {...item} />);
}

// ✅ 좋은 예: 고유한 ID 사용
{
	items.map((item) => <ListItem key={item.id} {...item} />);
}
```

## 가상 스크롤 (Virtual Scrolling)

대량의 데이터를 렌더링할 때는 `react-window`나 `react-virtualized` 사용을 고려하세요.

```jsx
import { FixedSizeList } from "react-window";

function LargeList({ items }) {
	return (
		<FixedSizeList height={600} itemCount={items.length} itemSize={50} width="100%">
			{({ index, style }) => <div style={style}>{items[index].name}</div>}
		</FixedSizeList>
	);
}
```

# 4. 상태 관리 최적화

## 상태 분리

하나의 상태로 여러 컴포넌트를 관리하면 불필요한 렌더링이 발생합니다.

```jsx
// ❌ 나쁜 예
function Dashboard() {
	const [state, setState] = useState({
		user: {},
		posts: [],
		notifications: []
	});

	// user만 변경되어도 전체 재렌더링
}

// ✅ 좋은 예
function Dashboard() {
	const [user, setUser] = useState({});
	const [posts, setPosts] = useState([]);
	const [notifications, setNotifications] = useState([]);

	// 각각 독립적으로 관리
}
```

## Context 분리

```jsx
// ❌ 하나의 Context에 모든 상태
const AppContext = createContext({ user, theme, settings });

// ✅ 목적별로 Context 분리
const UserContext = createContext(null);
const ThemeContext = createContext(null);
const SettingsContext = createContext(null);
```

# 5. 코드 스플리팅

## React.lazy & Suspense

```jsx
import { lazy, Suspense } from "react";

const HeavyComponent = lazy(() => import("./HeavyComponent"));

function App() {
	return (
		<Suspense fallback={<LoadingSpinner />}>
			<HeavyComponent />
		</Suspense>
	);
}
```

## 라우트 기반 코드 스플리팅

```jsx
const Home = lazy(() => import("./pages/Home"));
const Dashboard = lazy(() => import("./pages/Dashboard"));
const Settings = lazy(() => import("./pages/Settings"));

function Router() {
	return (
		<Suspense fallback={<PageLoader />}>
			<Routes>
				<Route path="/" element={<Home />} />
				<Route path="/dashboard" element={<Dashboard />} />
				<Route path="/settings" element={<Settings />} />
			</Routes>
		</Suspense>
	);
}
```

# 6. 성능 측정

## React DevTools Profiler

Chrome 확장 프로그램으로 컴포넌트 렌더링 시간을 측정할 수 있습니다.

## Performance API

```jsx
import { useEffect } from "react";

function PerformanceMonitor({ children }) {
	useEffect(() => {
		const observer = new PerformanceObserver((list) => {
			for (const entry of list.getEntries()) {
				console.log(entry.name, entry.duration);
			}
		});

		observer.observe({ entryTypes: ["measure"] });

		return () => observer.disconnect();
	}, []);

	return children;
}
```

# 정리

React 성능 최적화는 다음 원칙을 기억하세요:

1. **측정 먼저**: 추측하지 말고 측정하라
2. **필요한 곳에만**: 모든 곳에 최적화를 적용하지 말 것
3. **트레이드오프 고려**: 가독성과 유지보수성도 중요
4. **사용자 경험 우선**: 숫자보다 실제 UX 개선에 집중

성능 최적화는 끝이 없지만, 사용자가 체감할 수 있는 개선에 집중하는 것이 핵심입니다.

> 💡 **Pro Tip**: 성능 이슈가 발생하기 전에 미리 최적화하지 마세요.
> 실제 병목을 찾아 개선하는 것이 훨씬 효율적입니다.
